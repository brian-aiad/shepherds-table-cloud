rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    /* ===== Helpers ===== */
    function isAuthed() { return request.auth != null; }

    // Master override (claim preferred; email fallback)
    function isMaster() {
      return isAuthed()
        && (
          (request.auth.token.master == true)
          || (request.auth.token.email == "csbrianaiad@gmail.com")
        );
    }

    // orgUsers doc id: "<uid>_<orgId>"
    function orgUser(orgId) {
      return exists(/databases/$(database)/documents/orgUsers/$(request.auth.uid + "_" + orgId))
        ? get(/databases/$(database)/documents/orgUsers/$(request.auth.uid + "_" + orgId)).data
        : null;
    }

    function isAdminOfOrg(orgId) {
      return isMaster() || (isAuthed() && orgUser(orgId) != null && orgUser(orgId).role == "admin");
    }
    function isVolunteerOfOrg(orgId) {
      return isAuthed() && orgUser(orgId) != null && orgUser(orgId).role == "volunteer";
    }

    // Location access mirrors the app
    function hasLocationAccess(orgId, locationId) {
      return isAuthed()
        && orgUser(orgId) != null
        && (
          // admins
          (
            orgUser(orgId).role == "admin"
            && (
              (orgUser(orgId).scope == "all")
              || !(orgUser(orgId).locationIds is list)
              || (orgUser(orgId).locationIds is list && orgUser(orgId).locationIds.size() == 0)
              || (
                (locationId != null && locationId != "")
                ? true
                : (orgUser(orgId).scope == "all" || !(orgUser(orgId).locationIds is list) || orgUser(orgId).locationIds.size() == 0)
              )
            )
          )
          ||
          // volunteers
          (
            orgUser(orgId).role == "volunteer"
            && (
              (locationId == null || locationId == "")
                ? (orgUser(orgId).scope == "all")
                : (orgUser(orgId).locationIds is list && locationId in orgUser(orgId).locationIds)
            )
          )
          ||
          // master
          isMaster()
        );
    }

    function canActAt(orgId, locationId)      { return isMaster() || hasLocationAccess(orgId, locationId); }
    function canReadScoped(orgId, locationId)  { return canActAt(orgId, locationId); }
    function canWriteScoped(orgId, locationId) { return canActAt(orgId, locationId); }

    function hasOrgId() {
      return (request.resource.data.orgId is string) && request.resource.data.orgId.size() > 0;
    }
    function hasLocationId() {
      return (request.resource.data.locationId is string) && request.resource.data.locationId.size() > 0;
    }

    /* ===== Global master allow ===== */
    match /{document=**} {
      allow read, write: if isMaster();
    }

    /* ===== users ===== */
    match /users/{userId} {
      allow get, create, update: if isAuthed() && request.auth.uid == userId;
      allow list, delete: if false;
    }

    /* ===== orgUsers ===== */
    match /orgUsers/{id} {
      allow read: if isAuthed()
        && resource.data != null
        && resource.data.userId == request.auth.uid;
      allow create, update, delete: if false;
    }

    /* ===== organizations ===== */
    match /organizations/{orgId} {
      allow read: if isAuthed() && (isAdminOfOrg(orgId) || isVolunteerOfOrg(orgId));
      allow create, update, delete: if false;
    }

    /* ===== locations ===== */
    match /locations/{locationId} {
      allow read: if isAuthed()
        && resource.data != null
        && (isAdminOfOrg(resource.data.orgId) || isVolunteerOfOrg(resource.data.orgId));
      allow create, update, delete: if false;
    }

    /* ===== clients ===== */
    match /clients/{clientId} {
      // allow existence checks OR scoped reads
      allow read: if isAuthed() && (
        resource == null ||
        canReadScoped(resource.data.orgId, resource.data.locationId)
      );

      // create requires concrete org + location
      allow create: if isAuthed()
        && hasOrgId()
        && hasLocationId()
        && canWriteScoped(request.resource.data.orgId, request.resource.data.locationId);

      // update: identity immutable; admins broad, volunteers limited
      allow update: if isAuthed()
        && request.resource.data.orgId      == resource.data.orgId
        && request.resource.data.locationId == resource.data.locationId
        && hasLocationAccess(resource.data.orgId, resource.data.locationId)
        && (
          (isAdminOfOrg(resource.data.orgId)
            && !request.resource.data.diff(resource.data).changedKeys().hasAny(["orgId","locationId"]))
          ||
          (isVolunteerOfOrg(resource.data.orgId)
            && request.resource.data.diff(resource.data).changedKeys().hasOnly([
              "firstName","lastName","fullNameLower",
              "dob","nameDobHash",
              "phone","phoneDigits",
              "address","zip","county",
              "householdSize",
              "updatedAt","updatedByUserId"
            ]))
        );

      // delete: admin with scope
      allow delete: if isAuthed()
        && isAdminOfOrg(resource.data.orgId)
        && hasLocationAccess(resource.data.orgId, resource.data.locationId);
    }

    /* ===== visits ===== */
    match /visits/{visitId} {
      allow read: if isAuthed() && (
        resource == null ||
        canReadScoped(resource.data.orgId, resource.data.locationId)
      );

      // âœ… relaxed create rule:
      // user must have write access at the visit's location,
      // client must belong to same org,
      // and user must be able to read the client at its original location.
      allow create: if isAuthed()
        && hasOrgId()
        && hasLocationId()
        && canWriteScoped(request.resource.data.orgId, request.resource.data.locationId)
        && exists(/databases/$(database)/documents/clients/$(request.resource.data.clientId))
        && get(/databases/$(database)/documents/clients/$(request.resource.data.clientId)).data.orgId
             == request.resource.data.orgId
        && canReadScoped(
             request.resource.data.orgId,
             get(/databases/$(database)/documents/clients/$(request.resource.data.clientId)).data.locationId
           );

      // update: identity immutable
      allow update: if isAuthed()
        && canWriteScoped(resource.data.orgId, resource.data.locationId)
        && request.resource.data.clientId   == resource.data.clientId
        && request.resource.data.orgId      == resource.data.orgId
        && request.resource.data.locationId == resource.data.locationId
        && request.resource.data.dateKey    == resource.data.dateKey
        && request.resource.data.monthKey   == resource.data.monthKey;

      allow delete: if isAuthed()
        && isAdminOfOrg(resource.data.orgId)
        && hasLocationAccess(resource.data.orgId, resource.data.locationId);
    }

    /* ===== inventory ===== */
    match /inventory/{itemId} {
      // scoped reads + existence checks
      allow read: if isAuthed() && (
        resource == null ||
        canReadScoped(resource.data.orgId, resource.data.locationId)
      );

      // create: must specify org + location and have write access there
      allow create: if isAuthed()
        && hasOrgId()
        && hasLocationId()
        && canWriteScoped(request.resource.data.orgId, request.resource.data.locationId);

      // update: keep org/location fixed, require write access at that location
      allow update: if isAuthed()
        && canWriteScoped(resource.data.orgId, resource.data.locationId)
        && request.resource.data.orgId      == resource.data.orgId
        && request.resource.data.locationId == resource.data.locationId;

      // delete: admin with location access
      allow delete: if isAuthed()
        && isAdminOfOrg(resource.data.orgId)
        && hasLocationAccess(resource.data.orgId, resource.data.locationId);
    }

    /* ===== donations ===== */
    match /donations/{donationId} {
      // scoped reads + existence checks
      allow read: if isAuthed() && (
        resource == null ||
        canReadScoped(resource.data.orgId, resource.data.locationId)
      );

      // create: must specify org + location and have write access there
      allow create: if isAuthed()
        && hasOrgId()
        && hasLocationId()
        && canWriteScoped(request.resource.data.orgId, request.resource.data.locationId);

      // update: keep org/location fixed, require write access
      allow update: if isAuthed()
        && canWriteScoped(resource.data.orgId, resource.data.locationId)
        && request.resource.data.orgId      == resource.data.orgId
        && request.resource.data.locationId == resource.data.locationId;

      // delete: admin with location access
      allow delete: if isAuthed()
        && isAdminOfOrg(resource.data.orgId)
        && hasLocationAccess(resource.data.orgId, resource.data.locationId);
    }

    /* ===== reports ===== */
    match /reports/{reportId} {
      allow read:    if isAuthed() && isAdminOfOrg(resource.data.orgId);
      allow create:  if isAuthed() && hasOrgId() && isAdminOfOrg(request.resource.data.orgId);
      allow update:  if isAuthed() && isAdminOfOrg(resource.data.orgId);
      allow delete:  if isAuthed() && isAdminOfOrg(resource.data.orgId);
    }

    /* ===== usda_first ===== */
    match /usda_first/{markerId} {
      // Scoped reads; allow existence checks
      allow read: if isAuthed() && (
        resource == null ||
        canReadScoped(resource.data.orgId, resource.data.locationId)
      );

      // Create-once with deterministic id: "<orgId>_<clientId>_<monthKey>"
      // Use tx.create() in code; do not pre-read.
      allow create: if isAuthed()
        && hasOrgId()
        && (
             // locationId may be null/empty for org-wide admins; canActAt handles that.
             canWriteScoped(request.resource.data.orgId, request.resource.data.locationId)
           )
        // enforce ID format and values
        && (markerId == (request.resource.data.orgId + "_" +
                         request.resource.data.clientId + "_" +
                         request.resource.data.monthKey))
        // single create
        && !exists(/databases/$(database)/documents/usda_first/$(markerId));

      // No edits/deletes to monthly markers
      allow update, delete: if false;
    }

    /* ===== default deny ===== */
    match /{any=**} {
      allow read, write: if false;
    }
  }
}
