rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    /** ============================== Helpers =============================== */
    function lowerSafe(s) { return s == null ? null : toLower(s); }
    function isAuthed()  { return request.auth != null; }

    // ðŸ”‘ Master override â€” ONLY your account (email gate).
    function isMaster() {
      return isAuthed()
        && lowerSafe(request.auth.token.email) == "csbrianaiad@gmail.com";
      // If you also want to require a custom claim, add:
      // && request.auth.token.master == true
    }

    // orgUsers doc id convention: "<uid>_<orgId>"
    // Use literal-style path interpolation $(...) for get/exists.
    function orgUser(rawOrgId) {
      return exists(/databases/$(database)/documents/orgUsers/$(request.auth.uid + "_" + rawOrgId))
        ? get(   /databases/$(database)/documents/orgUsers/$(request.auth.uid + "_" + rawOrgId)).data
        : null;
    }

    // Role checks (scoped to a specific org)
    function isAdminOfOrg(rawOrgId) {
      let ou = orgUser(rawOrgId);
      return isMaster() || (isAuthed() && ou != null && ou.role == "admin");
    }
    function isVolunteerOfOrg(rawOrgId) {
      let ou = orgUser(rawOrgId);
      return isAuthed() && ou != null && ou.role == "volunteer";
    }

    // Volunteers must be assigned to the location they access.
    function volunteerHasLocation(rawOrgId, rawLocationId) {
      let ou = orgUser(rawOrgId);
      // `hasAny()` is the correct contains check for arrays.
      return isVolunteerOfOrg(rawOrgId)
        && ou.locationIds != null
        && ou.locationIds.hasAny([rawLocationId]);
    }

    // Convenience: read/write permission for a scoped (orgId, locationId) thing
    function canReadScoped(orgId, locationId) {
      return isAdminOfOrg(orgId) || volunteerHasLocation(orgId, locationId);
    }
    function canWriteScoped(orgId, locationId) {
      return isAdminOfOrg(orgId) || volunteerHasLocation(orgId, locationId);
    }

    // Required fields for new tenant-scoped docs
    function hasOrgId()      { return request.resource.data.orgId is string && request.resource.data.orgId.size() > 0; }
    function hasLocationId() { return request.resource.data.locationId is string && request.resource.data.locationId.size() > 0; }

    /** ========================== Global master allow ======================= */
    // Master can read/write everything, everywhere.
    match /{document=**} {
      allow read, write: if isMaster();
    }

    /** ============================== users ================================== */
    // Per-account sticky scope, private to each user.
    match /users/{userId} {
      allow get, create, update: if isAuthed() && request.auth.uid == userId;
      allow list, delete: if false;
    }

    /** ============================= orgUsers ================================ */
    // IMPORTANT: Do NOT call isAdminOfOrg() here (it reads orgUsers â†’ recursion).
    // Let users read ONLY their own orgUsers doc; master already allowed globally.
    match /orgUsers/{id} {
      allow read: if isAuthed()
        && resource.data != null
        && resource.data.userId == request.auth.uid;
      allow create, update, delete: if false; // master handled by global rule above
    }

    /** ========================== organizations ============================== */
    // Viewable by signed-in; writes are master-only (provisioning).
    match /organizations/{orgId} {
      allow read: if isAuthed();
      allow create, update, delete: if false; // master via global
    }

    /** ============================ locations ================================ */
    // Viewable by signed-in; writes are master-only (provisioning).
    match /locations/{locationId} {
      allow read: if isAuthed();
      allow create, update, delete: if false; // master via global
    }

    /** ============================== clients =================================
     *  Admins: full CRUD inside their org (including hard delete).
     *  Volunteers: READ-ONLY at assigned locations.
     *  orgId and locationId immutable after create (except master via global override).
     * ======================================================================= */
    match /clients/{clientId} {
      // Read: admin of org OR volunteer assigned to client.locationId
      allow read: if isAuthed() && canReadScoped(resource.data.orgId, resource.data.locationId);

      // Create: admin of the org, must include orgId & locationId
      allow create: if isAuthed()
        && hasOrgId()
        && hasLocationId()
        && isAdminOfOrg(request.resource.data.orgId);

      // Update: admin of the EXISTING org; tenant scope immutable
      allow update: if isAuthed()
        && isAdminOfOrg(resource.data.orgId)
        && request.resource.data.orgId      == resource.data.orgId
        && request.resource.data.locationId == resource.data.locationId;

      // Delete: admin of the org may hard delete
      allow delete: if isAuthed() && isAdminOfOrg(resource.data.orgId);
    }

    /** ============================== visits ================================== */
    match /visits/{visitId} {
      allow read: if isAuthed() && canReadScoped(resource.data.orgId, resource.data.locationId);

      allow create: if isAuthed()
        && hasOrgId()
        && hasLocationId()
        && canWriteScoped(request.resource.data.orgId, request.resource.data.locationId)
        // client must existâ€¦
        && exists(/databases/$(database)/documents/clients/$(request.resource.data.clientId))
        // â€¦and belong to the same org
        && get(/databases/$(database)/documents/clients/$(request.resource.data.clientId)).data.orgId
             == request.resource.data.orgId;

      allow update: if isAuthed()
        && canWriteScoped(resource.data.orgId, resource.data.locationId)
        // immutables
        && request.resource.data.clientId   == resource.data.clientId
        && request.resource.data.orgId      == resource.data.orgId
        && request.resource.data.locationId == resource.data.locationId
        && request.resource.data.dateKey    == resource.data.dateKey
        && request.resource.data.monthKey   == resource.data.monthKey;

      allow delete: if false; // keep audit history
    }

    /** ============================== reports ================================= */
    match /reports/{reportId} {
      allow read: if isAuthed() && isAdminOfOrg(resource.data.orgId);
      allow create, update, delete: if isAuthed() && isAdminOfOrg(resource.data.orgId);
    }

    /** ============================ usda_first ================================ */
    match /usda_first/{markerId} {
      allow read: if isAuthed();

      allow create: if isAuthed()
        && hasOrgId()
        && hasLocationId()
        && canWriteScoped(request.resource.data.orgId, request.resource.data.locationId)
        && !exists(/databases/$(database)/documents/usda_first/$(markerId));

      allow update, delete: if false;
    }

    /** ============================= Default deny ============================ */
    match /{any=**} {
      allow read, write: if false;
    }
  }
}
