rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    /** ============================== Helpers =============================== */
    function lowerSafe(s) { return s == null ? null : lower(s); }
    function isAuthed()  { return request.auth != null; }

    // ðŸ”‘ Master override â€” PREFERRED: custom claim; TEMP: legacy email.
    function isMaster() {
      return isAuthed()
        && (
          (request.auth.token.master == true)
          ||
          (lowerSafe(request.auth.token.email) == "csbrianaiad@gmail.com")
        );
    }

    // orgUsers doc id convention: "<uid>_<orgId>"
    function orgUser(rawOrgId) {
      return exists(/databases/$(database)/documents/orgUsers/$(request.auth.uid + "_" + rawOrgId))
        ? get(   /databases/$(database)/documents/orgUsers/$(request.auth.uid + "_" + rawOrgId)).data
        : null;
    }

    /** Role & Scope helpers (per-org) */
    function isAdminOfOrg(rawOrgId) {
      let ou = orgUser(rawOrgId);
      return isMaster() || (isAuthed() && ou != null && ou.role == "admin");
    }
    function isVolunteerOfOrg(rawOrgId) {
      let ou = orgUser(rawOrgId);
      return isAuthed() && ou != null && ou.role == "volunteer";
    }

    // Scoped location access:
    // Returns true if the signed-in user's membership for orgId allows access
    // to the given locationId (scope:"all" OR locationIds contains it).
    function hasLocationAccess(rawOrgId, rawLocationId) {
      let ou = orgUser(rawOrgId);
      return isAuthed()
        && ou != null
        && (
          (ou.scope == "all")
          ||
          (ou.locationIds is list && rawLocationId in ou.locationIds)
        );
    }

    // Unified capability to act at (orgId, locationId) respecting role+scope.
    // - Admins: may act only where their scope allows (all OR subset list).
    // - Volunteers: may act only within their assigned locations.
    function canActAt(rawOrgId, rawLocationId) {
      let ou = orgUser(rawOrgId);
      return isMaster()
        || (
          ou != null
          && (
            (ou.role == "admin"     && hasLocationAccess(rawOrgId, rawLocationId))
            ||
            (ou.role == "volunteer" && hasLocationAccess(rawOrgId, rawLocationId))
          )
        );
    }

    // Convenience wrappers for read/write at (org, location)
    function canReadScoped(orgId, locationId)  { return canActAt(orgId, locationId); }
    function canWriteScoped(orgId, locationId) { return canActAt(orgId, locationId); }

    // Required fields for new tenant-scoped docs
    function hasOrgId()      { return (request.resource.data.orgId is string) && request.resource.data.orgId.size() > 0; }
    function hasLocationId() { return (request.resource.data.locationId is string) && request.resource.data.locationId.size() > 0; }

    /** ========================== Global master allow ======================= */
    // Master can read/write everything, everywhere.
    match /{document=**} {
      allow read, write: if isMaster();
    }

    /** ============================== users ================================= */
    // Per-account sticky scope, private to each user.
    match /users/{userId} {
      allow get, create, update: if isAuthed() && request.auth.uid == userId;
      allow list, delete: if false;
    }

    /** ============================= orgUsers ================================ */
    // Users can read ONLY their own orgUsers docs. Membership writes are server-side (callables).
    match /orgUsers/{id} {
      allow read: if isAuthed()
        && resource.data != null
        && resource.data.userId == request.auth.uid;
      allow create, update, delete: if false; // (master handled by global block)
    }

    /** ========================== organizations ============================== */
    // Only members (admin or volunteer) of an org can read that org's doc.
    match /organizations/{orgId} {
      allow read: if isAuthed() && (isAdminOfOrg(orgId) || isVolunteerOfOrg(orgId));
      allow create, update, delete: if false; // (master via global)
    }

    /** ============================ locations ================================ */
    // Only members of the parent org can read its locations (scope not required just to list names).
    match /locations/{locationId} {
      allow read: if isAuthed()
        && resource.data != null
        && (isAdminOfOrg(resource.data.orgId) || isVolunteerOfOrg(resource.data.orgId));
      allow create, update, delete: if false; // (master via global)
    }

    /** ============================== clients ================================
     *  Admins: full CRUD inside their *allowed scope* (org + allowed locations).
     *  Volunteers: READ at assigned locations; may update ONLY visit counters
     *  and last-visit metadata (no tenant-scope changes, no profile edits).
     *  Volunteers may CREATE clients at assigned locations (dashboard flow).
     * ======================================================================= */
    match /clients/{clientId} {

      // Read: admin/volunteer WITH access to that location
      allow read: if isAuthed() && canReadScoped(resource.data.orgId, resource.data.locationId);

      // Create: admin/volunteer WITH access to the target location.
      // Must include orgId & locationId.
      allow create: if isAuthed()
        && hasOrgId()
        && hasLocationId()
        && canWriteScoped(request.resource.data.orgId, request.resource.data.locationId);

      // Update:
      //  â€¢ Admins (with scope) can update anything except tenant identity (org/location) must remain unchanged.
      //  â€¢ Volunteers (with scope) can ONLY change counter/last-visit fields.
      allow update: if isAuthed()
        && request.resource.data.orgId      == resource.data.orgId
        && request.resource.data.locationId == resource.data.locationId
        && (
          // Admin path (must have scope to this location)
          (isAdminOfOrg(resource.data.orgId) && hasLocationAccess(resource.data.orgId, resource.data.locationId))
          ||
          // Volunteer path: restricted fields & must have scope
          (
            hasLocationAccess(resource.data.orgId, resource.data.locationId)
            && isVolunteerOfOrg(resource.data.orgId)
            && request.resource.data.diff(resource.data).changedKeys()
              .hasOnly([
                "visitCountLifetime",
                "visitCountByMonth",
                "lastVisitAt",
                "lastVisitMonthKey",
                "updatedAt",
                "updatedByUserId",
                "householdSize" // optional: keep latest HH from visit workflow
              ])
          )
        );

      // Delete: admin WITH scope to that location may hard delete
      allow delete: if isAuthed()
        && isAdminOfOrg(resource.data.orgId)
        && hasLocationAccess(resource.data.orgId, resource.data.locationId);
    }

    /** ============================== visits =================================
     *  Create/Update/Delete allowed only where the user has scope (admin or volunteer).
     *  Identity fields (clientId/orgId/locationId/dateKey/monthKey) are immutable post-create.
     * ======================================================================= */
    match /visits/{visitId} {
      allow read: if isAuthed() && canReadScoped(resource.data.orgId, resource.data.locationId);

      allow create: if isAuthed()
        && hasOrgId()
        && hasLocationId()
        && canWriteScoped(request.resource.data.orgId, request.resource.data.locationId)
        // client must existâ€¦
        && exists(/databases/$(database)/documents/clients/$(request.resource.data.clientId))
        // â€¦and belong to the same org AND location
        && get(/databases/$(database)/documents/clients/$(request.resource.data.clientId)).data.orgId
             == request.resource.data.orgId
        && get(/databases/$(database)/documents/clients/$(request.resource.data.clientId)).data.locationId
             == request.resource.data.locationId;

      // Updates allowed but keep core identity immutable.
      allow update: if isAuthed()
        && canWriteScoped(resource.data.orgId, resource.data.locationId)
        && request.resource.data.clientId   == resource.data.clientId
        && request.resource.data.orgId      == resource.data.orgId
        && request.resource.data.locationId == resource.data.locationId
        && request.resource.data.dateKey    == resource.data.dateKey
        && request.resource.data.monthKey   == resource.data.monthKey;

      // Admin (WITH scope) may hard delete visits
      allow delete: if isAuthed()
        && isAdminOfOrg(resource.data.orgId)
        && hasLocationAccess(resource.data.orgId, resource.data.locationId);
    }

    /** ============================== reports =============================== */
    // Admin-only, org-scoped (no volunteer access). If you ever need location-scoped
    // reports for subset-admins, add a locationId in the doc and mirror canActAt.
    match /reports/{reportId} {
      allow read:    if isAuthed() && isAdminOfOrg(resource.data.orgId);
      allow create:  if isAuthed() && hasOrgId() && isAdminOfOrg(request.resource.data.orgId);
      allow update:  if isAuthed() && isAdminOfOrg(resource.data.orgId);
      allow delete:  if isAuthed() && isAdminOfOrg(resource.data.orgId);
    }

    /** ============================ usda_first =============================== */
    // Deterministic first-of-month markers; enforce (org,location) scope.
    match /usda_first/{markerId} {
      allow read: if isAuthed() && canReadScoped(resource.data.orgId, resource.data.locationId);

      allow create: if isAuthed()
        && hasOrgId()
        && hasLocationId()
        && canWriteScoped(request.resource.data.orgId, request.resource.data.locationId)
        && !exists(/databases/$(database)/documents/usda_first/$(markerId));
      // No updates/deletes.
      allow update, delete: if false;
    }

    /** ============================= Default deny ============================ */
    match /{any=**} {
      allow read, write: if false;
    }
  }
}
